Criando a tela :

    from kivy.app import App # importa a tela

    class NomeTela(App):
        def build(self):
            #conteudos da tela

    NomeTela.run() # Inicia a tela

    A def build é obrigatoria pois ela é quem é responsavel por inicar a tela, ela deve retornar o layout da tela.

Botão :

    from kivy.uix.button import Button # importa o Botão

    class NomeTela(App):
        def build(self):
            button = Button(text="Texto do botão")

    Insere um botão na interface.

    Paramentros :

        text = Texto do botão, string

        font_size = Tamanho da fonte do texto, float

        on_release = Função que será executada, assim que o botão for clicado essa função será executada, a função tem que pedir self e o botão como paramentros caso contrario ela não irá funcionar.

Label :

    from kivy.uix.label import Label # Importa a label

    class NomeTela(App):
        def build(self):
            label = Label(text="Texto")

    Basicamente serve para inserir um texto na tela.

    Paramentros :

        text = Texto do botão, string

        font_size = Tamanho da fonte do texto, float

BoxLayout : 

    from kivy.uix.boxlayout import BoxLayout # importa o BoxLayout que vai servir como base para o layout da tela

    class NomeTela(App):
        def build(self):
            box = BoxLayout(orientation="vertical") # por padrão é horizontal mas pode ser alterado conforme desejado
            button = Button(text="Botão 1") # cria um botão
            box.add_widget(button) # adiciona o botão a tela
            return box # Retorna a o layout

    Nota é possivel adicionar um layout dentro do outro, para isso é só criar o novo layout e adicionar usando o box.add_widget ao principal, dessa forma ao retornar será 2 layouts ao invés de um só.

Arquivo kivy:

    Esse arquivo serve para gerenciar o layout e é mais facil de trabalhar, deve ser escrito usando a linguagem kivy.

    Dentro do seu arquivo .py crie a classe de inicialização da interface:

        class Test(App):
            def build(self):
                return Incrementador()

        
    Essa classe irá retornar a interface, mas nesse caso estamos retornando uma outra classe chamada de Incrementador : 

        class Incrementador(BoxLayout):
            pass

    Essa classe herda a BoxLayout e simplismente é passada

    após isso crie o arquivo escrevendo em letras minusculas o nome da sua classe de inicialização da interface.kv, nesse caso "test.ky"

    Passe o nome da classe que irá ser retornada pela build dentro de <> :

        <Incrementador>:

    Como Incrementador herda a BoxLayout você pode configurar dentro dela as propiedades da box :

        orientation : 'vertical'

    Dentro desse espaço você deve configurar a interface, basicamente você irá colocar o Item de interface [button, label...] e as propiedades dele :

        Button : 
            text : 'Incrementar'
            font_size : 30
            on_release : label.text = str(int(label.text)+1)

        Label: 
            id : label
            text : '1'
            font_size : 30

    Esse id serve para verificarmos o valor da Label e modificarmos ele.

Interface dinamica :

    O exemplo anterior ilustrava bem uma interface que é estatica, porém caso queiramos que ela seja dinamica devemos trabalhar de forma diferente : 

        class Tarefas(BoxLayout):
        def __init__(self, tarefas, **kwargs):
            super().__init__(**kwargs)
            for tarefa in tarefas :
                self.add_widget(Label(text=tarefa, font_size=30))

    Básicamente nessa classe estamos pedindo uma lista de tarefas e adicionando a mesma ao BoxLayout, primeiramente o __init__ sempre é chamado ao iniciar a classe, pedimos o self, as tarefas e o **kwargs.

    O **kwargs é básicamente os argumentos do kivy, passando ele podemos modificar coisas da interface diretamente ao chamar a classe e evitamos que o progama se quebre.

    Após isso temos o super().__init__(**kwargs), essa classe super serve para chamar o __init__ do BoxLayout, assim evitando o __init__ seja rescrito e passamos o **kwargs evitando que o sistema quebre.

    Após isso adicionamos ao BoxLayout, Label que tem o texto que é o texto passado pela lista e o font_size, esses labels serão adicionados de acordo com o tamanho da lista.

        class Test(App):
            def build(self):
                return Tarefas(['Fazer compras', 'Ir para a escola', 'Regar as plantas'], orientation='horizontal')

    Quando instanciamos passamos a lista e a orientação que a tela deve ficar, essa orientação irá subistituir a que existe no arquivo Kivy.

BoxLayout paramentros :

    id : nome_da_id
    orientation : 'orientação'
    size_hint_y : None
    height : self.minimum_height

    size_hint_y = Por padrão começa em 1, assim a tela acaba sendo responsiva por cada número de elementos, se tiver 2, cada um irá ocupar 50% da tela, caso seja colocado como None, isso irá desligar a responsividade, assim você poderá organizar o espaçamento da forma que deseja.

    height = Determina o tamanho minimo que cada elemento irá ocupar em largura, para não fazer um monte de calculos malucos, utilize a função "self.minimum_height" que irá determinar o tamanho minimo.

ScrollView :

    ScrollView é como uma BoxLayout porém ele cria uma barra de rolagem lateral caso o tamanho do conteudo utrapasse o total da tela.

    class Tarefas(ScrollView):
        def __init__(self, tarefas, **kwargs):
            super().__init__(**kwargs)

    Nesse caso como estamos criando usando o ScrollView não podemos adicionar os elementos a ele, portanto precisamos acessar a BoxLayout, para isso usamos self.ids.id_da_box.add_widget(Elemento)

    for tarefa in tarefas :
        self.ids.box.add_widget(Label(text=tarefa, font_size=30, size_hint_y=None, height=200))

    Como desligamos a size_hint_y eles irão ficar uma bagunça, então precisamos desligar do Label e adicionar uma altura minima, que servirá de espaçamento entre os Labels.